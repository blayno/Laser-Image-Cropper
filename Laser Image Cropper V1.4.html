<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser Image Cropper</title>
<style>
body {
    font-family: Arial, sans-serif;
    background:#1e1e1e;
    color:#ddd;
    display:flex;
    justify-content:center; /* center horizontally */
    align-items:center;       /* vertical center */
    align-items:flex-start;
    padding:20px;
    height:100vh;
    box-sizing:border-box;
}

.container {
    display:flex;
    gap:40px; /* space between controls and canvas */
}

.controls {
    display:flex;
    flex-direction:column;
    min-width:200px;
}

.controls input,
.controls select,
.controls button {
    margin: 5px 0;
}

canvas {
    background:#333;
    cursor: grab;
    border:1px solid #555;
    width: 400px;    /* Force square */
    height: 400px;   /* Force square */
    flex-shrink: 0;  /* Don't allow flex to resize */
}


#outputInfo {
    margin-top:6px;
    font-size:13px;
    color:#9fd;
}
</style>
</head>
<body>

<div class="container">
    <!-- LEFT: Controls -->
    <div class="controls">
		
        <input type="file" id="fileInput" accept="image/*"><br>

        Shape<br>
        <select id="shape">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rounded">Rounded Square</option>
			<option value="heart">Heart</option> <!-- New -->
			<option value="star">Star</option> <!--New-->

        </select><br>
		<div id="outputInfo">—</div>
        Size<br>
        <input type="range" id="size" min="50" max="400" value="400"><br>		
		<div style="display:flex; align-items:center; gap:5px;">
			<input type="number" id="sizeNumber" value="400" style="width:80px">
			<select id="sizeUnit">
				<option value="px">px</option>
				<option value="mm">mm</option>
			</select>
		</div>
        </select>
        DPI
        <input type="number" id="dpi" value="96" style="width:70px"><br>
		
		Zoom<br>
        <input type="range" id="zoom" min="0.2" max="3" step="0.01" value="1"><br>

        Corner Radius (Rounded)<br>
        <input type="range" id="radius" min="0" max="200" value="40"><br>
		
		Star Points<br>
		<input type="number" id="starPoints" value="5" min="3" max="20" style="width:70px"><br>


        

        <button id="exportBtn">Export Cropped Image</button>
		
    </div>

    <!-- RIGHT: Canvas -->
	
	<!-- RIGHT: Canvas -->
	<div class="canvas-wrapper" style="display:flex; flex-direction:column; align-items:center;">
		<h2>Laser Image Cropper</h2> <!-- Label above canvas -->
		<canvas id="canvas" width="400" height="400"></canvas>
	</div>

	
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const fileInput = document.getElementById("fileInput");
const shapeSel = document.getElementById("shape");
const sizeSlider = document.getElementById("size");
const sizeNumber = document.getElementById("sizeNumber");
const sizeUnit = document.getElementById("sizeUnit");
const dpiInput = document.getElementById("dpi");
const radiusSlider = document.getElementById("radius");
const zoomSlider = document.getElementById("zoom");
const exportBtn = document.getElementById("exportBtn");
const outputInfo = document.getElementById("outputInfo");

const CANVAS_SIZE = canvas.width;

const starPointsInput = document.getElementById("starPoints");


let cropSize = CANVAS_SIZE;
let cornerRadius = 40;
let scale = 1;
let imgX = 0, imgY = 0;
let img = new Image();

let dragging = false;
let lastX = 0, lastY = 0;

/*-----------Listener star value---------------*/
starPointsInput.addEventListener("input", () => {
    let val = parseInt(starPointsInput.value);
    if (isNaN(val) || val < 3) val = 3;
    if (val > 20) val = 20;
    starPointsInput.value = val;
    draw();
});


/* ---------- UNIT CONVERSION ---------- */
function mmToPx(mm) {
    return (mm / 25.4) * parseFloat(dpiInput.value || 254);
}

function pxToMm(px) {
    return (px / parseFloat(dpiInput.value || 254)) * 25.4;
}

/* ---------- SHAPE PATH ---------- */
function buildShapePath(ctx, size, radius, shape) {
    const cx = CANVAS_SIZE / 2;
    const cy = CANVAS_SIZE / 2;
    const x = cx - size / 2;
    const y = cy - size / 2;

    ctx.beginPath();

    if (shape === "circle") {
        ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);

    } else if (shape === "square") {
        ctx.rect(x, y, size, size);

    } else if (shape === "rounded") {
        const r = Math.min(radius, size / 2);
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + size, y, x + size, y + size, r);
        ctx.arcTo(x + size, y + size, x, y + size, r);
        ctx.arcTo(x, y + size, x, y, r);
        ctx.arcTo(x, y, x + size, y, r);

    } else if (shape === "heart") {

        const scaleX = 1.2;
        const scaleY = 1.28;

        const top = y + size * 0.35;
        const lobeY = y;
        const bottom = y + size;
        const left = x;
        const right = x + size;

        ctx.save();

        // scale about center
        ctx.translate(cx, cy);
        ctx.scale(scaleX, scaleY);
        ctx.translate(-cx, -cy);

        // keep tip on bottom of bounding box
        const scaledBottom = cy + (bottom - cy) * scaleY;
        const offsetY = bottom - scaledBottom;
        ctx.translate(0, offsetY);

        ctx.moveTo(cx, bottom);

        ctx.bezierCurveTo(
            cx + size * 0.6, y + size * 0.75,
            right, lobeY,
            cx, top
        );

        ctx.bezierCurveTo(
            left, lobeY,
            cx - size * 0.6, y + size * 0.75,
            cx, bottom
        );

        ctx.restore();

} else if (shape === "star") {

    const spikes = parseInt(starPointsInput.value || 5);
    const cx = CANVAS_SIZE / 2;
    const cy = CANVAS_SIZE / 2;
    const outerRadius = size / 2;
    const innerRadius = outerRadius * 0.45;
    const rot = -Math.PI / 2;
    const step = Math.PI / spikes;

    // Precompute star points relative to center
    const points = [];
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    for (let i = 0; i < spikes * 2; i++) {
        const r = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = rot + step * i;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        points.push({ x, y });
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
    }

    // Calculate scale to fit crop size
    const starWidth = maxX - minX;
    const starHeight = maxY - minY;
    const scaleX = size / starWidth;
    const scaleY = size / starHeight;

    // Centering offsets
    const offsetX = (minX + maxX) / 2;
    const offsetY = (minY + maxY) / 2;

    ctx.save();

    // Scale around center
    ctx.translate(cx, cy);
    ctx.scale(scaleX, scaleY);
    ctx.translate(-cx, -cy);

    // Draw star points
    ctx.moveTo(cx + points[0].x - offsetX, cy + points[0].y - offsetY);
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(cx + points[i].x - offsetX, cy + points[i].y - offsetY);
    }



		ctx.restore();
	}


    ctx.closePath();
}


/* ---------- OUTPUT INFO ---------- */
function updateOutputInfo() {
    const px = cropSize;
    const mm = pxToMm(px).toFixed(2);
    const shape = shapeSel.value;

    let label =
        shape === "circle" ? "Ø" :
        shape === "square" ? "□" :
        shape === "rounded" ? "Rounded" :
        "♥";

    if (sizeUnit.value === "mm") {
        outputInfo.textContent = `${label} ${mm} mm → ${px} px`;
    } else {
        outputInfo.textContent = `${label} ${px} px → ${mm} mm`;
    }
}

/* ---------- DRAW ---------- */
function draw() {
    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

    ctx.save();
    buildShapePath(ctx, cropSize, cornerRadius, shapeSel.value);
    ctx.clip();

    if (img.src) {
        ctx.drawImage(img, imgX, imgY, img.width * scale, img.height * scale);
    }

    ctx.restore();

    buildShapePath(ctx, cropSize, cornerRadius, shapeSel.value);
    ctx.strokeStyle = "#00ffcc";
    ctx.lineWidth = 2;
    ctx.stroke();

    updateOutputInfo();
}

/* ---------- IMAGE LOAD ---------- */
fileInput.addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
        img.onload = () => {
            scale = Math.max(cropSize / img.width, cropSize / img.height);
            zoomSlider.value = scale;
            imgX = (CANVAS_SIZE - img.width * scale) / 2;
            imgY = (CANVAS_SIZE - img.height * scale) / 2;
            draw();
        };
        img.src = reader.result;
    };
    reader.readAsDataURL(file);
});

/* ---------- CONTROLS ---------- */
zoomSlider.addEventListener("input", () => {
    const old = scale;
    scale = parseFloat(zoomSlider.value);
    const c = CANVAS_SIZE / 2;
    imgX = c - (c - imgX) * (scale / old);
    imgY = c - (c - imgY) * (scale / old);
    draw();
});

sizeSlider.addEventListener("input", () => {
    cropSize = parseInt(sizeSlider.value);
    sizeNumber.value = sizeUnit.value === "mm" ? pxToMm(cropSize).toFixed(2) : cropSize;
    draw();
});

sizeNumber.addEventListener("input", () => {
    let val = parseFloat(sizeNumber.value);
    if (isNaN(val) || val <= 0) return;

    let px = sizeUnit.value === "mm" ? mmToPx(val) : val;
    cropSize = Math.max(10, Math.min(CANVAS_SIZE, Math.round(px)));
    sizeSlider.value = cropSize;
    draw();
});

sizeUnit.addEventListener("change", () => {
    sizeNumber.value = sizeUnit.value === "mm" ? pxToMm(cropSize).toFixed(2) : cropSize;
    updateOutputInfo();
});

dpiInput.addEventListener("input", () => {
    if (sizeUnit.value === "mm") {
        cropSize = Math.round(mmToPx(parseFloat(sizeNumber.value)));
        sizeSlider.value = cropSize;
        draw();
    }
});

radiusSlider.addEventListener("input", () => {
    cornerRadius = parseInt(radiusSlider.value);
    draw();
});

shapeSel.addEventListener("change", draw);

/* ---------- DRAG ---------- */
canvas.addEventListener("mousedown", e => {
    dragging = true;
    lastX = e.offsetX;
    lastY = e.offsetY;
    canvas.style.cursor = "grabbing";
});

canvas.addEventListener("mousemove", e => {
    if (!dragging) return;
    imgX += e.offsetX - lastX;
    imgY += e.offsetY - lastY;
    lastX = e.offsetX;
    lastY = e.offsetY;
    draw();
});

canvas.addEventListener("mouseup", () => {
    dragging = false;
    canvas.style.cursor = "grab";
});
canvas.addEventListener("mouseleave", () => dragging = false);

/* ---------- EXPORT ---------- */
exportBtn.addEventListener("click", () => {
    const out = document.createElement("canvas");
    out.width = cropSize;
    out.height = cropSize;
    const octx = out.getContext("2d");

    buildShapePath(octx, cropSize, cornerRadius, shapeSel.value);
    octx.clip();

    const offset = (CANVAS_SIZE - cropSize) / 2;
    octx.drawImage(img, imgX - offset, imgY - offset, img.width * scale, img.height * scale);

    const link = document.createElement("a");
    link.download = "crop.png";
    link.href = out.toDataURL("image/png");
    link.click();
});

/* ---------- INIT ---------- */
updateOutputInfo();
</script>


</body>
</html>
Written by Blayne Hixson and Chat GPT