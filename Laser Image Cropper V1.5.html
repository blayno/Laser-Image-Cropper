<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser Image Cropper</title>
<style>
body {
    font-family: Arial, sans-serif;
    background:#1e1e1e;
    color:#ddd;
    display:flex;
    justify-content:center; /* center horizontally */
    align-items:center;       /* vertical center */
    align-items:flex-start;
    padding:20px;
    height:100vh;
    box-sizing:border-box;
}

.container {
    display:flex;
    gap:40px; /* space between controls and canvas */
}

.controls {
    display:flex;
    flex-direction:column;
    min-width:200px;
}

.controls input,
.controls select,
.controls button {
    margin: 5px 0;
}

canvas {
    background:#333;
    cursor: grab;
    border:1px solid #555;
    width: 400px;    /* Force square */
    height: 400px;   /* Force square */
    flex-shrink: 0;  /* Don't allow flex to resize */
}


#outputInfo {
    margin-top:6px;
    font-size:13px;
    color:#9fd;
}
</style>
</head>
<body>

<div class="container">
    <!-- LEFT: Controls -->
    <div class="controls">
		
        <input type="file" id="fileInput" accept="image/*"><br>

        Shape<br>
        <select id="shape">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rounded">Rounded Square</option>
			<option value="heart">Heart</option> <!-- New -->
			<option value="star">Star</option> <!--New-->
			<option value="dogtag">Dog Tag</option> <!--New-->


        </select><br>
		<div id="outputInfo">â€”</div>
        Size<br>
        <input type="range" id="size" min="50" max="400" value="400"><br>		
		<div style="display:flex; align-items:center; gap:5px;">
			<input type="number" id="sizeNumber" value="400" style="width:80px">
			<select id="sizeUnit">
				<option value="px">px</option>
				<option value="mm">mm</option>
			</select>
		</div>
        </select>
        DPI
        <input type="number" id="dpi" value="96" style="width:70px"><br>
		
		Zoom<br>
        <input type="range" id="zoom" min="0.2" max="3" step="0.01" value="1"><br>

        Corner Radius (Rounded)<br>
        <input type="range" id="radius" min="0" max="200" value="40"><br>
		
        <br>
		<div style="display: flex; align-items: center; gap: 10px;">
		<label for="starPoints">Star Points:</label>
		<span id="starPointsValue" style="font-size:13px; color:#9fd;">5</span>
		</div>
		<input type="range" id="starPoints" min="3" max="20" value="5">

        <button id="exportBtn">Export Cropped Image</button>
		
    </div>

    <!-- RIGHT: Canvas -->
	
	<!-- RIGHT: Canvas -->
	<div class="canvas-wrapper" style="display:flex; flex-direction:column; align-items:center;">
		<h2>Laser Image Cropper</h2> <!-- Label above canvas -->
		<canvas id="canvas" width="400" height="400"></canvas>
	</div>

	
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const fileInput = document.getElementById("fileInput");
const shapeSel = document.getElementById("shape");
const sizeSlider = document.getElementById("size");
const sizeNumber = document.getElementById("sizeNumber");
const sizeUnit = document.getElementById("sizeUnit");
const dpiInput = document.getElementById("dpi");
const radiusSlider = document.getElementById("radius");
const zoomSlider = document.getElementById("zoom");
const exportBtn = document.getElementById("exportBtn");
const outputInfo = document.getElementById("outputInfo");

const CANVAS_SIZE = canvas.width;

const starPointsInput = document.getElementById("starPoints");


let cropSize = CANVAS_SIZE;
let cornerRadius = 40;
let scale = 1;
let imgX = 0, imgY = 0;
let img = new Image();

let dragging = false;
let lastX = 0, lastY = 0;

/*-----------Listener star value---------------*/
const starPointsValue = document.getElementById("starPointsValue");

starPointsInput.addEventListener("input", () => {
    const val = parseInt(starPointsInput.value);
    starPointsValue.textContent = val;
    draw();
});


/* ---------- UNIT CONVERSION ---------- */
function mmToPx(mm) {
    return (mm / 25.4) * parseFloat(dpiInput.value || 254);
}

function pxToMm(px) {
    return (px / parseFloat(dpiInput.value || 254)) * 25.4;
}

/* ---------- SHAPE PATH ---------- */
function buildShapePath(ctx, size, radius, shape) {
    const cx = CANVAS_SIZE / 2;
    const cy = CANVAS_SIZE / 2;
    const x = cx - size / 2;
    const y = cy - size / 2;

    ctx.beginPath();

    if (shape === "circle") {
        ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);

    } else if (shape === "square") {
        ctx.rect(x, y, size, size);

    } else if (shape === "rounded") {
        const r = Math.min(radius, size / 2);
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + size, y, x + size, y + size, r);
        ctx.arcTo(x + size, y + size, x, y + size, r);
        ctx.arcTo(x, y + size, x, y, r);
        ctx.arcTo(x, y, x + size, y, r);

    } else if (shape === "heart") {

    const scaleX = 1.2;
    const scaleY = 1.34;

    const top = y + size * 0.35;
    const lobeY = y;
    const bottom = y + size;
    const left = x;
    const right = x + size;

    ctx.save();

    // ðŸ”’ scale about the heart tip (bottom center)
    ctx.translate(cx, bottom);
    ctx.scale(scaleX, scaleY);
    ctx.translate(-cx, -bottom);

    ctx.beginPath();
    ctx.moveTo(cx, bottom);

    ctx.bezierCurveTo(
        cx + size * 0.6, y + size * 0.75,
        right, lobeY,
        cx, top
    );

    ctx.bezierCurveTo(
        left, lobeY,
        cx - size * 0.6, y + size * 0.75,
        cx, bottom
    );

    
    ctx.restore();



} else if (shape === "star") {

    const spikes = parseInt(starPointsInput.value || 5);
    const cx = CANVAS_SIZE / 2;
    const cy = CANVAS_SIZE / 2;
    const outerRadius = size / 2;
    const innerRadius = outerRadius * 0.45;
    const rot = -Math.PI / 2;
    const step = Math.PI / spikes;

    // Precompute star points relative to center
    const points = [];
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    for (let i = 0; i < spikes * 2; i++) {
        const r = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = rot + step * i;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        points.push({ x, y });
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
    }

    // Calculate scale to fit crop size
    const starWidth = maxX - minX;
    const starHeight = maxY - minY;
    const scaleX = size / starWidth;
    const scaleY = size / starHeight;

    // Centering offsets
    const offsetX = (minX + maxX) / 2;
    const offsetY = (minY + maxY) / 2;

    ctx.save();

    // Scale around center
    ctx.translate(cx, cy);
    ctx.scale(scaleX, scaleY);
    ctx.translate(-cx, -cy);

    // Draw star points
    ctx.moveTo(cx + points[0].x - offsetX, cy + points[0].y - offsetY);
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(cx + points[i].x - offsetX, cy + points[i].y - offsetY);
    }



		ctx.restore();
	}

	else if (shape === "dogtag") {
		const cx = CANVAS_SIZE / 2;
		const cy = CANVAS_SIZE / 2;
		const width = size * 0.6;
		const height = size;
		const x = cx - width / 2;
		const y = cy - height / 2;

		// Make corners more rounded like a real dog tag
		const maxRadius = Math.min(width, height) * 1; // almost half of width/height
		const r = Math.min(cornerRadius, maxRadius);

		// Draw rounded rectangle
		ctx.moveTo(x + r, y);
		ctx.arcTo(x + width, y, x + width, y + height, r);
		ctx.arcTo(x + width, y + height, x, y + height, r);
		ctx.arcTo(x, y + height, x, y, r);
		ctx.arcTo(x, y, x + width, y, r);

		// Draw small hole at top for chain
		const holeRadius = size * 0.03;        // size of hole
		const holeOffset = size * 0.13;        // distance from top edge
		const holeY = y + holeOffset + holeRadius; // fixed position
		ctx.moveTo(cx + holeRadius, holeY);
		ctx.arc(cx, holeY, holeRadius, 0, Math.PI * 2);

		// IMPORTANT: when clipping later in draw(), use even-odd rule
		// ctx.clip("evenodd"); 
		// This ensures the hole blocks the image
	}



    ctx.closePath();
}


/* ---------- OUTPUT INFO ---------- */
function updateOutputInfo() {
    const px = cropSize;
    const mm = pxToMm(px).toFixed(2);
    const shape = shapeSel.value;

let label =
    shape === "circle"  ? "Ã˜" :
    shape === "square"  ? "â–¡" :
    shape === "rounded" ? "Rounded" :
    shape === "star"    ? "â˜…" :
    shape === "dogtag"  ? "Dog Tag" :
    "â™¥";


    if (sizeUnit.value === "mm") {
        outputInfo.textContent = `${label} ${mm} mm â†’ ${px} px`;
    } else {
        outputInfo.textContent = `${label} ${px} px â†’ ${mm} mm`;
    }
}

/* ---------- DRAW ---------- */
function draw() {
    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

    ctx.save();
    buildShapePath(ctx, cropSize, cornerRadius, shapeSel.value);
    ctx.clip("evenodd");

    if (img.src) {
        ctx.drawImage(img, imgX, imgY, img.width * scale, img.height * scale);
    }

    ctx.restore();

    buildShapePath(ctx, cropSize, cornerRadius, shapeSel.value);
    ctx.strokeStyle = "#00ffcc";
    ctx.lineWidth = 2;
    ctx.stroke();

    updateOutputInfo();
}

/* ---------- IMAGE LOAD ---------- */
fileInput.addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
        img.onload = () => {
            scale = Math.max(cropSize / img.width, cropSize / img.height);
            zoomSlider.value = scale;
            imgX = (CANVAS_SIZE - img.width * scale) / 2;
            imgY = (CANVAS_SIZE - img.height * scale) / 2;
            draw();
        };
        img.src = reader.result;
    };
    reader.readAsDataURL(file);
});

/* ---------- CONTROLS ---------- */
zoomSlider.addEventListener("input", () => {
    const old = scale;
    scale = parseFloat(zoomSlider.value);
    const c = CANVAS_SIZE / 2;
    imgX = c - (c - imgX) * (scale / old);
    imgY = c - (c - imgY) * (scale / old);
    draw();
});

sizeSlider.addEventListener("input", () => {
    cropSize = parseInt(sizeSlider.value);
    sizeNumber.value = sizeUnit.value === "mm" ? pxToMm(cropSize).toFixed(2) : cropSize;
    draw();
});

sizeNumber.addEventListener("input", () => {
    let val = parseFloat(sizeNumber.value);
    if (isNaN(val) || val <= 0) return;

    let px = sizeUnit.value === "mm" ? mmToPx(val) : val;
    cropSize = Math.max(10, Math.min(CANVAS_SIZE, Math.round(px)));
    sizeSlider.value = cropSize;
    draw();
});

sizeUnit.addEventListener("change", () => {
    sizeNumber.value = sizeUnit.value === "mm" ? pxToMm(cropSize).toFixed(2) : cropSize;
    updateOutputInfo();
});

dpiInput.addEventListener("input", () => {
    if (sizeUnit.value === "mm") {
        cropSize = Math.round(mmToPx(parseFloat(sizeNumber.value)));
        sizeSlider.value = cropSize;
        draw();
    }
});

radiusSlider.addEventListener("input", () => {
    cornerRadius = parseInt(radiusSlider.value);
    draw();
});

shapeSel.addEventListener("change", draw);

/* ---------- DRAG ---------- */
canvas.addEventListener("mousedown", e => {
    dragging = true;
    lastX = e.offsetX;
    lastY = e.offsetY;
    canvas.style.cursor = "grabbing";
});

canvas.addEventListener("mousemove", e => {
    if (!dragging) return;
    imgX += e.offsetX - lastX;
    imgY += e.offsetY - lastY;
    lastX = e.offsetX;
    lastY = e.offsetY;
    draw();
});

canvas.addEventListener("mouseup", () => {
    dragging = false;
    canvas.style.cursor = "grab";
});
canvas.addEventListener("mouseleave", () => dragging = false);

/* ---------- EXPORT ---------- */
exportBtn.addEventListener("click", () => {
    const out = document.createElement("canvas");
    out.width = cropSize;
    out.height = cropSize;
    const octx = out.getContext("2d");

    buildShapePath(octx, cropSize, cornerRadius, shapeSel.value);
    octx.clip("evenodd");


    const offset = (CANVAS_SIZE - cropSize) / 2;
    octx.drawImage(img, imgX - offset, imgY - offset, img.width * scale, img.height * scale);

    const link = document.createElement("a");
    link.download = "crop.png";
    link.href = out.toDataURL("image/png");
    link.click();
});

/* ---------- INIT ---------- */
updateOutputInfo();
</script>


</body>
</html>
Written by Blayne Hixson and Chat GPT